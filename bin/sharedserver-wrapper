#!/bin/bash
# sharedserver-wrapper - Transparent process wrapper with refcounting
#
# Usage: sharedserver-wrapper <server-name> <command> [args...]
#
# This wrapper:
# 1. Increments refcount in lockfile
# 2. Forks an efficient watcher process
# 3. Execs into the actual server (becomes transparent)
# 4. Watcher decrements refcount when server exits
#
# The result is that the calling process sees the real server PID
# and has direct stdio connection, while refcounting happens invisibly.

set -euo pipefail

# Configuration
LOCKDIR="${SHAREDSERVER_LOCKDIR:-${XDG_RUNTIME_DIR:-/tmp}/sharedserver}"
DEBUG="${SHAREDSERVER_DEBUG:-0}"

# Arguments
if [ $# -lt 2 ]; then
    echo "Usage: $0 <server-name> <command> [args...]" >&2
    exit 1
fi

SERVER_NAME="$1"
shift
ACTUAL_COMMAND="$1"
shift
ACTUAL_ARGS=("$@")

LOCKFILE="$LOCKDIR/${SERVER_NAME}.lock.json"
LOCKFILE_LOCK="$LOCKFILE.lock"
MY_PID=$$

# Ensure lockdir exists
mkdir -p "$LOCKDIR"

# Debug logging helper
debug() {
    if [ "$DEBUG" = "1" ]; then
        echo "[sharedserver-wrapper:$$] $*" >&2
    fi
}

debug "Starting wrapper for '$SERVER_NAME' (command: $ACTUAL_COMMAND)"

# Atomic lockfile operations using flock
increment_refcount() {
    debug "Acquiring lock on $LOCKFILE_LOCK"
    exec 200>"$LOCKFILE_LOCK"
    flock -x 200

    if [ -f "$LOCKFILE" ]; then
        # Existing server - increment refcount
        local current_refcount
        current_refcount=$(jq -r '.refcount' "$LOCKFILE")
        debug "Server already running, incrementing refcount from $current_refcount"

        jq '.refcount += 1' "$LOCKFILE" > "$LOCKFILE.tmp"
        mv "$LOCKFILE.tmp" "$LOCKFILE"
    else
        # New server - create lockfile
        debug "Creating new lockfile with refcount=1"
        cat > "$LOCKFILE" <<EOF
{
    "pid": $MY_PID,
    "server_name": "$SERVER_NAME",
    "refcount": 1,
    "started_at": $(date +%s),
    "watcher_pid": null
}
EOF
    fi
}

# Fork watcher process that waits efficiently for server to exit
fork_watcher() {
    debug "Forking watcher for PID $MY_PID"

    # The watcher uses a compiled helper for efficiency if available,
    # otherwise falls back to polling with exponential backoff
    local watcher_script="$LOCKDIR/watcher-$MY_PID.sh"

    # Create watcher script
    cat > "$watcher_script" <<'WATCHER_SCRIPT'
#!/bin/bash
SERVER_PID="$1"
LOCKFILE="$2"
LOCKFILE_LOCK="$3"

# Efficient wait using kill -0 with exponential backoff
wait_for_exit() {
    local sleep_time=0.1
    local max_sleep=5

    while kill -0 "$SERVER_PID" 2>/dev/null; do
        sleep "$sleep_time"
        # Exponential backoff, cap at max_sleep
        sleep_time=$(awk "BEGIN {s=$sleep_time*1.5; print (s>$max_sleep)?$max_sleep:s}")
    done
}

# Wait for server to exit
wait_for_exit

# Decrement refcount atomically
exec 200>"$LOCKFILE_LOCK"
flock -x 200

if [ -f "$LOCKFILE" ]; then
    REFCOUNT=$(jq -r '.refcount' "$LOCKFILE")

    if [ "$REFCOUNT" -le 1 ]; then
        # Last reference - remove lockfile
        rm -f "$LOCKFILE" "$LOCKFILE_LOCK"
    else
        # Decrement refcount
        jq '.refcount -= 1' "$LOCKFILE" > "$LOCKFILE.tmp"
        mv "$LOCKFILE.tmp" "$LOCKFILE"
    fi
fi

flock -u 200

# Cleanup watcher script
rm -f "$0"
WATCHER_SCRIPT

    chmod +x "$watcher_script"

    # Fork watcher in detached session
    setsid "$watcher_script" "$MY_PID" "$LOCKFILE" "$LOCKFILE_LOCK" &
    WATCHER_PID=$!

    debug "Watcher started with PID $WATCHER_PID"

    # Update lockfile with watcher PID (still holding lock from increment_refcount)
    jq ".watcher_pid = $WATCHER_PID" "$LOCKFILE" > "$LOCKFILE.tmp"
    mv "$LOCKFILE.tmp" "$LOCKFILE"

    # Release lock (will be closed on exec anyway, but explicit is good)
    flock -u 200
    exec 200>&-
}

# Cleanup on error (before exec)
cleanup_on_error() {
    debug "Cleanup on error"
    exec 200>"$LOCKFILE_LOCK"
    flock -x 200

    if [ -f "$LOCKFILE" ]; then
        local refcount
        refcount=$(jq -r '.refcount' "$LOCKFILE")

        if [ "$refcount" -le 1 ]; then
            rm -f "$LOCKFILE" "$LOCKFILE_LOCK"
        else
            jq '.refcount -= 1' "$LOCKFILE" > "$LOCKFILE.tmp"
            mv "$LOCKFILE.tmp" "$LOCKFILE"
        fi
    fi

    flock -u 200
}

# Verify command exists
if ! command -v "$ACTUAL_COMMAND" &>/dev/null; then
    echo "sharedserver-wrapper: command not found: $ACTUAL_COMMAND" >&2
    increment_refcount
    cleanup_on_error
    exit 127
fi

# Execute wrapper logic
increment_refcount
fork_watcher

debug "Exec'ing into $ACTUAL_COMMAND with args: ${ACTUAL_ARGS[*]}"

# Replace this process with the actual server
# This is the magic: our PID stays the same, but we become the server
# stdio remains connected, and the calling process gets our PID (which is now the server)
exec "$ACTUAL_COMMAND" "${ACTUAL_ARGS[@]}"

# If we reach here, exec failed
echo "sharedserver-wrapper: exec failed for command: $ACTUAL_COMMAND" >&2
cleanup_on_error
exit 1
